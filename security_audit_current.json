{"dependencies": [{"name": "amqp", "version": "5.3.1", "vulns": []}, {"name": "anaconda-anon-usage", "skip_reason": "Dependency not found on PyPI and could not be audited: anaconda-anon-usage (0.7.3)"}, {"name": "anaconda-auth", "version": "0.10.0", "vulns": []}, {"name": "anaconda-cli-base", "version": "0.5.4", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anthropic", "version": "0.75.0", "vulns": []}, {"name": "anyio", "version": "4.11.0", "vulns": []}, {"name": "archspec", "version": "0.2.5", "vulns": []}, {"name": "asgiref", "version": "3.11.0", "vulns": []}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "bcrypt", "version": "5.0.0", "vulns": []}, {"name": "beanie", "version": "2.0.0", "vulns": []}, {"name": "billiard", "version": "4.2.4", "vulns": []}, {"name": "boltons", "version": "25.0.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "boto3", "version": "1.42.12", "vulns": []}, {"name": "botocore", "version": "1.42.12", "vulns": []}, {"name": "brotlicffi", "version": "1.0.9.2", "vulns": []}, {"name": "cachecontrol", "version": "0.14.4", "vulns": []}, {"name": "cachetools", "version": "6.2.2", "vulns": []}, {"name": "celery", "version": "5.3.4", "vulns": []}, {"name": "certifi", "version": "2025.10.5", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.3", "vulns": []}, {"name": "click", "version": "8.3.0", "vulns": []}, {"name": "click-didyoumean", "version": "0.3.1", "vulns": []}, {"name": "click-plugins", "version": "1.1.1.2", "vulns": []}, {"name": "click-repl", "version": "0.3.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "conda", "skip_reason": "Dependency not found on PyPI and could not be audited: conda (25.9.1)"}, {"name": "conda-anaconda-telemetry", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-anaconda-telemetry (0.3.0)"}, {"name": "conda-anaconda-tos", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-anaconda-tos (0.2.2)"}, {"name": "conda-content-trust", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-content-trust (0.2.0)"}, {"name": "conda-libmamba-solver", "skip_reason": "Dependency not found on PyPI and could not be audited: conda-libmamba-solver (25.4.0)"}, {"name": "conda-package-handling", "version": "2.4.0", "vulns": []}, {"name": "conda-package-streaming", "version": "0.12.0", "vulns": []}, {"name": "coverage", "version": "7.3.2", "vulns": []}, {"name": "cryptography", "version": "41.0.7", "vulns": [{"id": "PYSEC-2024-225", "fix_versions": ["42.0.4"], "aliases": ["CVE-2024-26130", "GHSA-6vqw-3v5j-54x4"], "description": "cryptography is a package designed to expose cryptographic primitives and recipes to Python developers. Starting in version 38.0.0 and prior to version 42.0.4, if `pkcs12.serialize_key_and_certificates` is called with both a certificate whose public key did not match the provided private key and an `encryption_algorithm` with `hmac_hash` set (via `PrivateFormat.PKCS12.encryption_builder().hmac_hash(...)`, then a NULL pointer dereference would occur, crashing the Python process. This has been resolved in version 42.0.4, the first version in which a `ValueError` is properly raised."}, {"id": "CVE-2023-50782", "fix_versions": ["42.0.0"], "aliases": ["GHSA-3ww4-gg4f-jr7f"], "description": "A flaw was found in the python-cryptography package. This issue may allow a remote attacker to decrypt captured messages in TLS servers that use RSA key exchanges, which may lead to exposure of confidential or sensitive data."}, {"id": "CVE-2024-0727", "fix_versions": ["42.0.2"], "aliases": ["GHSA-9v9h-cgj8-h64p"], "description": "Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL to crash leading to a potential Denial of Service attack  Impact summary: Applications loading files in the PKCS12 format from untrusted sources might terminate abruptly.  A file in PKCS12 format can contain certificates and keys and may come from an untrusted source. The PKCS12 specification allows certain fields to be NULL, but OpenSSL does not correctly check for this case. This can lead to a NULL pointer dereference that results in OpenSSL crashing. If an application processes PKCS12 files from an untrusted source using the OpenSSL APIs then that application will be vulnerable to this issue.  OpenSSL APIs that are vulnerable to this are: PKCS12_parse(), PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes() and PKCS12_newpass().  We have also fixed a similar issue in SMIME_write_PKCS7(). However since this function is related to writing data we do not consider it security significant.  The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue."}, {"id": "GHSA-h4gh-qq45-vh27", "fix_versions": ["43.0.1"], "aliases": [], "description": "pyca/cryptography's wheels include a statically linked copy of OpenSSL. The versions of OpenSSL included in cryptography 37.0.0-43.0.0 are vulnerable to a security issue. More details about the vulnerability itself can be found in https://openssl-library.org/news/secadv/20240903.txt.  If you are building cryptography source (\"sdist\") then you are responsible for upgrading your copy of OpenSSL. Only users installing from wheels built by the cryptography project (i.e., those distributed on PyPI) need to update their cryptography versions. "}]}, {"name": "cyclonedx-python-lib", "version": "11.6.0", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deprecation", "version": "2.1.0", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "django", "version": "4.2.16", "vulns": [{"id": "PYSEC-2025-13", "fix_versions": ["4.2.20", "5.0.13", "5.1.7"], "aliases": ["GHSA-p3fp-8748-vqfq", "CVE-2025-26699"], "description": "An issue was discovered in Django 5.1 before 5.1.7, 5.0 before 5.0.13, and 4.2 before 4.2.20. The django.utils.text.wrap() method and wordwrap template filter are subject to a potential denial-of-service attack when used with very long strings."}, {"id": "PYSEC-2025-37", "fix_versions": ["4.2.21", "5.1.9", "5.2.1"], "aliases": ["CVE-2025-32873", "GHSA-8j24-cjrq-gr2m"], "description": "An issue was discovered in Django 4.2 before 4.2.21, 5.1 before 5.1.9, and 5.2 before 5.2.1. The django.utils.html.strip_tags() function is vulnerable to a potential denial-of-service (slow performance) when processing inputs containing large sequences of incomplete HTML tags. The template filter striptags is also vulnerable, because it is built on top of strip_tags()."}, {"id": "PYSEC-2024-157", "fix_versions": ["4.2.17", "5.0.10", "5.1.4"], "aliases": ["GHSA-m9g8-fxxm-xg86", "CVE-2024-53908"], "description": "An issue was discovered in Django 5.1 before 5.1.4, 5.0 before 5.0.10, and 4.2 before 4.2.17. Direct usage of the django.db.models.fields.json.HasKey lookup, when an Oracle database is used, is subject to SQL injection if untrusted data is used as an lhs value. (Applications that use the jsonfield.has_key lookup via __ are unaffected.)"}, {"id": "PYSEC-2024-156", "fix_versions": ["4.2.17", "5.0.10", "5.1.4"], "aliases": ["CVE-2024-53907", "GHSA-8498-2h75-472j"], "description": "An issue was discovered in Django 5.1 before 5.1.4, 5.0 before 5.0.10, and 4.2 before 4.2.17. The strip_tags() method and striptags template filter are subject to a potential denial-of-service attack via certain inputs containing large sequences of nested incomplete HTML entities."}, {"id": "PYSEC-2025-1", "fix_versions": ["4.2.18", "5.0.11", "5.1.5"], "aliases": ["GHSA-qcgg-j2x8-h9g8", "CVE-2024-56374"], "description": "An issue was discovered in Django 5.1 before 5.1.5, 5.0 before 5.0.11, and 4.2 before 4.2.18. Lack of upper-bound limit enforcement in strings passed when performing IPv6 validation could lead to a potential denial-of-service attack. The undocumented and private functions clean_ipv6_address and is_valid_ipv6_address are vulnerable, as is the django.forms.GenericIPAddressField form field. (The django.db.models.GenericIPAddressField model field is not affected.)"}, {"id": "PYSEC-2025-47", "fix_versions": ["4.2.22", "5.1.10", "5.2.2"], "aliases": ["CVE-2025-48432", "GHSA-7xr5-9hcq-chf9"], "description": "An issue was discovered in Django 5.2 before 5.2.2, 5.1 before 5.1.10, and 4.2 before 4.2.22. Internal HTTP response logging does not escape request.path, which allows remote attackers to potentially manipulate log output via crafted URLs. This may lead to log injection or forgery when logs are viewed in terminals or processed by external systems."}, {"id": "CVE-2025-57833", "fix_versions": ["4.2.24", "5.1.12", "5.2.6"], "aliases": ["GHSA-6w2r-r2m5-xq5w"], "description": "An issue was discovered in Django 4.2 before 4.2.24, 5.1 before 5.1.12, and 5.2 before 5.2.6. FilteredRelation is subject to SQL injection in column aliases, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed QuerySet.annotate() or QuerySet.alias()."}, {"id": "CVE-2025-59681", "fix_versions": ["4.2.25", "5.1.13", "5.2.7"], "aliases": ["GHSA-hpr9-3m2g-3j9p"], "description": "An issue was discovered in Django 4.2 before 4.2.25, 5.1 before 5.1.13, and 5.2 before 5.2.7. QuerySet.annotate(), QuerySet.alias(), QuerySet.aggregate(), and QuerySet.extra() are subject to SQL injection in column aliases, when using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed to these methods (on MySQL and MariaDB)."}, {"id": "CVE-2025-59682", "fix_versions": ["4.2.25", "5.1.13", "5.2.7"], "aliases": ["GHSA-q95w-c7qg-hrff"], "description": "An issue was discovered in Django 4.2 before 4.2.25, 5.1 before 5.1.13, and 5.2 before 5.2.7. The django.utils.archive.extract() function, used by the \"startapp --template\" and \"startproject --template\" commands, allows partial directory traversal via an archive with file paths sharing a common prefix with the target directory."}, {"id": "CVE-2025-64458", "fix_versions": ["4.2.26", "5.1.14", "5.2.8"], "aliases": ["GHSA-qw25-v68c-qjf3"], "description": "An issue was discovered in 5.1 before 5.1.14, 4.2 before 4.2.26, and 5.2 before 5.2.8. NFKC normalization in Python is slow on Windows. As a consequence, `django.http.HttpResponseRedirect`, `django.http.HttpResponsePermanentRedirect`, and the shortcut `django.shortcuts.redirect`  were subject to a potential  denial-of-service attack via certain inputs with a very large number of Unicode characters. Earlier, unsupported Django series (such as 5.0.x, 4.1.x, and 3.2.x) were not evaluated and may also be affected. Django would like to thank Seokchan Yoon for reporting this issue."}, {"id": "CVE-2025-64459", "fix_versions": ["4.2.26", "5.1.14", "5.2.8"], "aliases": ["GHSA-frmv-pr5f-9mcr"], "description": "An issue was discovered in 5.1 before 5.1.14, 4.2 before 4.2.26, and 5.2 before 5.2.8. The methods `QuerySet.filter()`, `QuerySet.exclude()`, and `QuerySet.get()`, and the class `Q()`, are subject to SQL injection when using a suitably crafted dictionary, with dictionary expansion, as the `_connector` argument. Earlier, unsupported Django series (such as 5.0.x, 4.1.x, and 3.2.x) were not evaluated and may also be affected. Django would like to thank cyberstan for reporting this issue."}, {"id": "CVE-2025-13372", "fix_versions": ["4.2.27", "5.1.15", "5.2.9"], "aliases": ["GHSA-rqw2-ghq9-44m7"], "description": "An issue was discovered in 5.2 before 5.2.9, 5.1 before 5.1.15, and 4.2 before 4.2.27. `FilteredRelation` is subject to SQL injection in column aliases, using a suitably crafted dictionary, with dictionary expansion, as the `**kwargs` passed to `QuerySet.annotate()` or `QuerySet.alias()` on PostgreSQL. Earlier, unsupported Django series (such as 5.0.x, 4.1.x, and 3.2.x) were not evaluated and may also be affected. Django would like to thank Stackered for reporting this issue."}, {"id": "CVE-2025-64460", "fix_versions": ["4.2.27", "5.1.15", "5.2.9"], "aliases": ["GHSA-vrcr-9hj9-jcg6"], "description": "An issue was discovered in 5.2 before 5.2.9, 5.1 before 5.1.15, and 4.2 before 4.2.27. Algorithmic complexity in `django.core.serializers.xml_serializer.getInnerText()` allows a remote attacker to cause a potential denial-of-service attack triggering CPU and memory exhaustion via specially crafted XML input processed by the XML `Deserializer`. Earlier, unsupported Django series (such as 5.0.x, 4.1.x, and 3.2.x) were not evaluated and may also be affected. Django would like to thank Seokchan Yoon for reporting this issue."}]}, {"name": "django-cors-headers", "version": "4.3.1", "vulns": []}, {"name": "django-redis", "version": "5.4.0", "vulns": []}, {"name": "djangorestframework", "version": "3.14.0", "vulns": [{"id": "CVE-2024-21520", "fix_versions": ["3.15.2"], "aliases": ["GHSA-gw84-84pc-xp82"], "description": "Versions of the package djangorestframework before 3.15.2 are vulnerable to Cross-site Scripting (XSS) via the break_long_headers template filter due to improper input sanitization before splitting and joining with <br> tags."}]}, {"name": "djangorestframework-simplejwt", "version": "5.3.0", "vulns": [{"id": "CVE-2024-22513", "fix_versions": ["5.5.1"], "aliases": ["GHSA-5vcc-86wm-547q"], "description": "djangorestframework-simplejwt before version 5.5.1 is vulnerable to information disclosure. A user can access web application resources even after their account has been disabled due to missing user validation checks via the for_user method."}]}, {"name": "dnspython", "version": "2.8.0", "vulns": []}, {"name": "docstring-parser", "version": "0.17.0", "vulns": []}, {"name": "ecdsa", "version": "0.19.1", "vulns": [{"id": "CVE-2024-23342", "fix_versions": [], "aliases": ["GHSA-wj6h-64fc-37mp"], "description": "python-ecdsa has been found to be subject to a Minerva timing attack on the P-256 curve. Using the `ecdsa.SigningKey.sign_digest()` API function and timing signatures an attacker can leak the internal nonce which may allow for private key discovery. Both ECDSA signatures, key generation, and ECDH operations are affected. ECDSA signature verification is unaffected. The python-ecdsa project considers side channel attacks out of scope for the project and there is no planned fix."}]}, {"name": "email-validator", "version": "2.3.0", "vulns": []}, {"name": "factory-boy", "version": "3.3.1", "vulns": []}, {"name": "faker", "version": "40.1.0", "vulns": []}, {"name": "fastapi", "version": "0.118.0", "vulns": []}, {"name": "filelock", "version": "3.20.2", "vulns": []}, {"name": "frozendict", "version": "2.4.2", "vulns": []}, {"name": "fsspec", "version": "2025.12.0", "vulns": []}, {"name": "google-ai-generativelanguage", "version": "0.6.15", "vulns": []}, {"name": "google-api-core", "version": "2.28.1", "vulns": []}, {"name": "google-api-python-client", "version": "2.187.0", "vulns": []}, {"name": "google-auth", "version": "2.43.0", "vulns": []}, {"name": "google-auth-httplib2", "version": "0.3.0", "vulns": []}, {"name": "google-cloud-secret-manager", "version": "2.26.0", "vulns": []}, {"name": "google-genai", "version": "1.52.0", "vulns": []}, {"name": "google-generativeai", "version": "0.8.6", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.72.0", "vulns": []}, {"name": "grpc-google-iam-v1", "version": "0.14.3", "vulns": []}, {"name": "grpcio", "version": "1.76.0", "vulns": []}, {"name": "grpcio-status", "version": "1.71.2", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "h2", "version": "4.3.0", "vulns": []}, {"name": "hpack", "version": "4.1.0", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httplib2", "version": "0.31.0", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "hyperframe", "version": "6.1.0", "vulns": []}, {"name": "hypothesis", "version": "6.92.1", "vulns": []}, {"name": "idna", "version": "3.10", "vulns": []}, {"name": "iniconfig", "version": "2.1.0", "vulns": []}, {"name": "jaraco-classes", "version": "3.4.0", "vulns": []}, {"name": "jaraco-context", "skip_reason": "Dependency not found on PyPI and could not be audited: jaraco-context (0.0.0)"}, {"name": "jaraco-functools", "version": "4.1.0", "vulns": []}, {"name": "jiter", "version": "0.11.0", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "keyring", "version": "25.6.0", "vulns": []}, {"name": "kombu", "version": "5.6.2", "vulns": []}, {"name": "lazy-model", "version": "0.3.0", "vulns": []}, {"name": "libmambapy", "skip_reason": "Dependency not found on PyPI and could not be audited: libmambapy (2.3.2)"}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "menuinst", "skip_reason": "Dependency not found on PyPI and could not be audited: menuinst (2.3.1)"}, {"name": "mmh3", "version": "5.2.0", "vulns": []}, {"name": "more-itertools", "version": "10.8.0", "vulns": []}, {"name": "motor", "version": "3.7.1", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "multidict", "version": "6.7.0", "vulns": []}, {"name": "neo4j", "version": "6.0.3", "vulns": []}, {"name": "openai", "version": "2.1.0", "vulns": []}, {"name": "orjson", "version": "3.11.5", "vulns": []}, {"name": "packageurl-python", "version": "0.17.6", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "passlib", "version": "1.7.4", "vulns": []}, {"name": "pillow", "version": "10.4.0", "vulns": []}, {"name": "pip", "version": "25.2", "vulns": [{"id": "CVE-2025-8869", "fix_versions": ["25.3"], "aliases": ["GHSA-4xh5-x5gv-qwph"], "description": "When extracting a tar archive pip may not check symbolic links point into the extraction directory if the tarfile module doesn't implement PEP 706. Note that upgrading pip to a \"fixed\" version for this vulnerability doesn't fix all known vulnerabilities that are remediated by using a Python version that implements PEP 706. Note that this is a vulnerability in pip's fallback implementation of tar extraction for Python versions that don't implement PEP 706 and therefore are not secure to all vulnerabilities in the Python 'tarfile' module. If you're using a Python version that implements PEP 706 then pip doesn't use the \"vulnerable\" fallback code. Mitigations include upgrading to a version of pip that includes the fix, upgrading to a Python version that implements PEP 706 (Python >=3.9.17, >=3.10.12, >=3.11.4, or >=3.12), applying the linked patch, or inspecting source distributions (sdists) before installation as is already a best-practice."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.10.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "pkce", "version": "1.0.3", "vulns": []}, {"name": "platformdirs", "version": "4.3.7", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "postgrest", "version": "2.27.0", "vulns": []}, {"name": "prompt-toolkit", "version": "3.0.52", "vulns": []}, {"name": "propcache", "version": "0.4.1", "vulns": []}, {"name": "proto-plus", "version": "1.27.0", "vulns": []}, {"name": "protobuf", "version": "5.29.5", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": []}, {"name": "pyasn1-modules", "version": "0.4.2", "vulns": []}, {"name": "pycosat", "version": "0.6.6", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pycryptodome", "version": "3.19.0", "vulns": []}, {"name": "pydantic", "version": "2.11.10", "vulns": []}, {"name": "pydantic-core", "version": "2.33.2", "vulns": []}, {"name": "pydantic-settings", "version": "2.11.0", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyiceberg", "version": "0.10.0", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pymongo", "version": "4.15.2", "vulns": []}, {"name": "pymupdf", "version": "1.26.5", "vulns": []}, {"name": "pymysql", "version": "1.1.1", "vulns": []}, {"name": "pyparsing", "version": "3.2.5", "vulns": []}, {"name": "pyroaring", "version": "1.0.3", "vulns": []}, {"name": "pysocks", "version": "1.7.1", "vulns": []}, {"name": "pytest", "version": "7.4.3", "vulns": []}, {"name": "pytest-asyncio", "version": "1.2.0", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "pytest-django", "version": "4.7.0", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-decouple", "version": "3.8", "vulns": []}, {"name": "python-dotenv", "version": "1.1.1", "vulns": []}, {"name": "python-jose", "version": "3.5.0", "vulns": []}, {"name": "python-multipart", "version": "0.0.20", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pywin32-ctypes", "version": "0.2.2", "vulns": []}, {"name": "readchar", "version": "4.2.1", "vulns": []}, {"name": "realtime", "version": "2.27.0", "vulns": []}, {"name": "redis", "version": "5.0.1", "vulns": []}, {"name": "requests", "version": "2.31.0", "vulns": [{"id": "CVE-2024-35195", "fix_versions": ["2.32.0"], "aliases": ["GHSA-9wx4-h78v-vm56"], "description": "When making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same origin will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool.  ### Remediation Any of these options can be used to remediate the current issue, we highly recommend upgrading as the preferred mitigation.  * Upgrade to `requests>=2.32.0`. * For `requests<2.32.0`, avoid setting `verify=False` for the first request to a host while using a Requests Session. * For `requests<2.32.0`, call `close()` on `Session` objects to clear existing connections if `verify=False` is used.  ### Related Links * https://github.com/psf/requests/pull/6655"}, {"id": "CVE-2024-47081", "fix_versions": ["2.32.4"], "aliases": ["GHSA-9hjg-9r4m-mvj7"], "description": "### Impact  Due to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.  ### Workarounds For older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).  ### References https://github.com/psf/requests/pull/6965 https://seclists.org/fulldisclosure/2025/Jun/2"}]}, {"name": "rich", "version": "14.2.0", "vulns": []}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.18.10", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.12", "vulns": []}, {"name": "s3transfer", "version": "0.16.0", "vulns": []}, {"name": "semver", "version": "3.0.2", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "shellingham", "version": "1.5.0", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "sqlparse", "version": "0.5.5", "vulns": []}, {"name": "starlette", "version": "0.48.0", "vulns": [{"id": "CVE-2025-62727", "fix_versions": ["0.49.1"], "aliases": ["GHSA-7f5h-v6xp-fcq8"], "description": "### Summary An unauthenticated attacker can send a crafted HTTP Range header that triggers quadratic-time processing in Starlette's `FileResponse` Range parsing/merging logic. This enables CPU exhaustion per request, causing denial\u2011of\u2011service for endpoints serving files (e.g., `StaticFiles` or any use of `FileResponse`).  ### Details Starlette parses multi-range requests in ``FileResponse._parse_range_header()``, then merges ranges using an O(n^2) algorithm.  ```python # starlette/responses.py _RANGE_PATTERN = re.compile(r\"(\\d*)-(\\d*)\") # vulnerable to O(n^2) complexity ReDoS  class FileResponse(Response):     @staticmethod     def _parse_range_header(http_range: str, file_size: int) -> list[tuple[int, int]]:         ranges: list[tuple[int, int]] = []         try:             units, range_ = http_range.split(\"=\", 1)         except ValueError:             raise MalformedRangeHeader()          # [...]          ranges = [             (                 int(_[0]) if _[0] else file_size - int(_[1]),                 int(_[1]) + 1 if _[0] and _[1] and int(_[1]) < file_size else file_size,             )             for _ in _RANGE_PATTERN.findall(range_) # vulnerable             if _ != (\"\", \"\")         ]  ```  The parsing loop of ``FileResponse._parse_range_header()`` uses the regular expression which vulnerable to denial of service for its O(n^2) complexity. A crafted `Range` header can maximize its complexity.  The merge loop processes each input range by scanning the entire result list, yielding quadratic behavior with many disjoint ranges. A crafted Range header with many small, non-overlapping ranges (or specially shaped numeric substrings) maximizes comparisons.    This affects any Starlette application that uses:    - ``starlette.staticfiles.StaticFiles`` (internally returns `FileResponse`) \u2014 `starlette/staticfiles.py:178`   - Direct ``starlette.responses.FileResponse`` responses  ### PoC ```python #!/usr/bin/env python3  import sys import time  try:     import starlette     from starlette.responses import FileResponse except Exception as e:     print(f\"[ERROR] Failed to import starlette: {e}\")     sys.exit(1)   def build_payload(length: int) -> str:     \"\"\"Build the Range header value body: '0' * num_zeros + '0-'\"\"\"     return (\"0\" * length) + \"a-\"   def test(header: str, file_size: int) -> float:     start = time.perf_counter()     try:         FileResponse._parse_range_header(header, file_size)     except Exception:         pass     end = time.perf_counter()     elapsed = end - start     return elapsed   def run_once(num_zeros: int) -> None:     range_body = build_payload(num_zeros)     header = \"bytes=\" + range_body     # Use a sufficiently large file_size so upper bounds default to file size     file_size = max(len(range_body) + 10, 1_000_000)          print(f\"[DEBUG] range_body length: {len(range_body)} bytes\")     elapsed_time = test(header, file_size)     print(f\"[DEBUG] elapsed time: {elapsed_time:.6f} seconds\\n\")   if __name__ == \"__main__\":     print(f\"[INFO] Starlette Version: {starlette.__version__}\")     for n in [5000, 10000, 20000, 40000]:         run_once(n)  \"\"\" $ python3 poc_dos_range.py [INFO] Starlette Version: 0.48.0 [DEBUG] range_body length: 5002 bytes [DEBUG] elapsed time: 0.053932 seconds  [DEBUG] range_body length: 10002 bytes [DEBUG] elapsed time: 0.209770 seconds  [DEBUG] range_body length: 20002 bytes [DEBUG] elapsed time: 0.885296 seconds  [DEBUG] range_body length: 40002 bytes [DEBUG] elapsed time: 3.238832 seconds \"\"\" ```  ### Impact Any Starlette app serving files via FileResponse or StaticFiles; frameworks built on Starlette (e.g., FastAPI) are indirectly impacted when using file-serving endpoints. Unauthenticated remote attackers can exploit this via a single HTTP request with a crafted Range header."}]}, {"name": "storage3", "version": "2.27.0", "vulns": []}, {"name": "strenum", "version": "0.4.15", "vulns": []}, {"name": "strictyaml", "version": "1.7.3", "vulns": []}, {"name": "supabase", "version": "2.27.0", "vulns": []}, {"name": "supabase-auth", "version": "2.27.0", "vulns": []}, {"name": "supabase-functions", "version": "2.27.0", "vulns": []}, {"name": "tenacity", "version": "9.1.2", "vulns": []}, {"name": "tomli", "version": "2.2.1", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "truststore", "version": "0.10.1", "vulns": []}, {"name": "typer", "version": "0.17.4", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "tzdata", "version": "2025.3", "vulns": []}, {"name": "uritemplate", "version": "4.2.0", "vulns": []}, {"name": "urllib3", "version": "2.5.0", "vulns": [{"id": "CVE-2025-66418", "fix_versions": ["2.6.0"], "aliases": ["GHSA-gm62-xv2j-4w53"], "description": "## Impact  urllib3 supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., `Content-Encoding: gzip, zstd`).  However, the number of links in the decompression chain was unbounded allowing a malicious server to insert a virtually unlimited number of compression steps leading to high CPU usage and massive memory allocation for the decompressed data.   ## Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier for HTTP requests to untrusted sources unless they disable content decoding explicitly.   ## Remediation  Upgrade to at least urllib3 v2.6.0 in which the library limits the number of links to 5.  If upgrading is not immediately possible, use [`preload_content=False`](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) and ensure that `resp.headers[\"content-encoding\"]` contains a safe number of encodings before reading the response content."}, {"id": "CVE-2025-66471", "fix_versions": ["2.6.0"], "aliases": ["GHSA-2xpw-w6gg-jr37"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  When streaming a compressed response, urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). The library must read compressed data from the network and decompress it until the requested chunk size is met. Any resulting decompressed data that exceeds the requested amount is held in an internal buffer for the next read operation.  The decompression logic could cause urllib3 to fully decode a small amount of highly compressed data in a single operation. This can result in excessive resource consumption (high CPU usage and massive memory allocation for the decompressed data; CWE-409) on the client side, even if the application only requested a small chunk of data.   ### Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier to stream large compressed responses or content from untrusted sources.  `stream()`, `read(amt=256)`, `read1(amt=256)`, `read_chunked(amt=256)`, `readinto(b)` are examples of `urllib3.HTTPResponse` method calls using the affected logic unless decoding is disabled explicitly.   ### Remediation  Upgrade to at least urllib3 v2.6.0 in which the library avoids decompressing data that exceeds the requested amount.  If your environment contains a package facilitating the Brotli encoding, upgrade to at least Brotli 1.2.0 or brotlicffi 1.2.0.0 too. These versions are enforced by the `urllib3[brotli]` extra in the patched versions of urllib3.   ### Credits  The issue was reported by @Cycloctane. Supplemental information was provided by @stamparm during a security audit performed by [7ASecurity](https://7asecurity.com/) and facilitated by [OSTIF](https://ostif.org/)."}]}, {"name": "uvicorn", "version": "0.37.0", "vulns": []}, {"name": "vine", "version": "5.1.0", "vulns": []}, {"name": "wcwidth", "version": "0.2.14", "vulns": []}, {"name": "websockets", "version": "15.0.1", "vulns": []}, {"name": "wheel", "version": "0.45.1", "vulns": []}, {"name": "win-inet-pton", "version": "1.1.0", "vulns": []}, {"name": "yarl", "version": "1.22.0", "vulns": []}, {"name": "zstandard", "version": "0.24.0", "vulns": []}], "fixes": []}
